---
title: Link Research
---

# Link Research

## To Research

* [isomorf.io](http://isomorf.io/)
  * [live tour](https://isomorf.io/#!/tour)
  * [blog](https://medium.com/isomorf-blog)
* [Whats Functional Programming All About](http://www.lihaoyi.com/post/WhatsFunctionalProgrammingAllAbout.html#what-functional-programming-is-not)
* [General Principles for a Generalized Idea Garden](https://www.researchgate.net/publication/313369217_General_Principles_for_a_Generalized_Idea_Garden)
  * get back to Jonathan Edwards after reading this one!
* [Usability Analysis of Visual Programming Environments](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.35.815&rep=rep1&type=pdf)
* [A Module System for a General-Purpose Blocks Language](http://www.vpri.org/pdf/tr2015003_modsys.pdf)
* [CycleJS Component Difficulties](https://www.youtube.com/watch?v=CU8jtb6UBGg&feature=youtu.be&t=46m15s)
* https://noflojs.org/
* [Joe Edelman - citizen logisitics](http://nxhx.org/) and [Chatterbase](http://alpha.trycarbide.com/@jxe/6d5e19369ddb9cc4728510e11a3f7586)


### Unordered

* spend time with Lively Kernal
* learn about HyperCard!
* [code.world](https://code.world/#PgOPqtxOVsfDQJe7-GkGdnQ)
* [SKETCHPAD A MAN-MACHINE GRAPHICAL COMMUNICATION SYSTEM - Sutherland](https://www.cs.purdue.edu/homes/hosking/197/canon/sutherland.pdf)
* look into heap analytics for its similarity to streamsheets (from Joe West)
* research moon script and the indie game community as it pertains to influencing WoofJS (joe west reccomended this)
* [Data-Oriented Design by Richard Fabian](http://www.dataorienteddesign.com/dodmain/)
* [Stencil – A reusable web component generator](https://news.ycombinator.com/item?id=15080174)
* [http://digitalfreepen.com/2017/08/16/elixir-in-depth-notes.html](http://digitalfreepen.com/2017/08/16/elixir-in-depth-notes.html)
* [John Carmack's keynote at Quakecon 2013 part 4](https://www.youtube.com/watch?v=1PhArSujR_A)
* http://www.luna-lang.org/
* https://www.touchdevelop.com
* http://nxhx.org/
* http://wagn.org/
* Vi Hart
* [Maude](https://www.youtube.com/watch?v=mZE_Xv9qym4), which comes highly reccomended by Ezekiel Smithburg from the Future Programming Slack.
* http://worrydream.com/substroke/
* [ICFP 2012. Roly Perera: Functional Programs that Explain their Work.](https://www.youtube.com/watch?v=pqtqaL_ojpk&feature=plcp)
* [Pacific Northwest Scala 2013 We're Doing It All Wrong by Paul Phillips](https://www.youtube.com/watch?v=TS1lpKBMkgg)
*http://www.subtext-lang.org/
* Furure of Programming Workshop - http://www.future-programming.org/
* http://www.kenperlin.com/
* http://harc.ycr.org/flex/
* http://alpha.trycarbide.com/
* [Chorus](http://www.chorus-home.org/)
* Kite.com
* PureScript
* https://elixir-lang.org/
* http://www.eff-lang.org/
* https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/TFM.pdf
* Idris
* http://conal.net/papers/Eros/
* http://tinyletter.com/Flowsheets/
* http://shaunlebron.github.io/parinfer/
* https://www.sourcetrail.com/
* http://www.clickteam.com/multimedia-fusion-2
* Unity
* https://www.scirra.com/construct2
* https://www.hyperpad.com/
* Thunkable
* https://powerapps.microsoft.com/en-us/
* http://www.ragic.com/
* http://www.chorus-home.org/
* Jet Brains MPS
* http://www.greenfoot.org/frames/
* http://flowlab.io
* http://embrio.io/
* http://harc.ycr.org/project/gp/
* [Tulip](https://www.youtube.com/watch?v=lvclTCDeIsY)
* https://www.pipes.digital/
* https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/
* http://www.memex.org/licklider.pdf
* http://web.media.mit.edu/~minsky/papers/TuringLecture/TuringLecture.html
* [Computer as Communications Device](https://www.dropbox.com/s/4td8aj5gglf4qfj/The%20Computer%20As%20A%20Communications%20Device.pdf?dl=0)
* http://www.red-lang.org/p/about.html
* https://cospaces.io/edu/
* Lively Kernal
* [Seymour Papert On Logo](http://el.media.mit.edu/logo-foundation/resources/onlogo/index.html)
* [Type Systems for Beginners](https://gilbert.ghost.io/type-systems-for-beginners-an-introduction/)
* [Types, Logic, Semantics, and Verification](https://www.cs.uoregon.edu/research/summerschool/summer15/curriculum.html)
* [Framer 3](https://www.producthunt.com/posts/framer-3)
* https://en.wikipedia.org/wiki/Prograph
* http://www.andescotia.com/products/marten/
* https://github.com/reflex-frp/reflex
* reasonML
* http://conal.net/blog/posts/reimagining-matrices

## Researched

* [Computer Software - 1984](http://www.vpri.org/pdf/tr1984001_comp_soft.pdf)
  * "A powerful genre can serve as wings or chians. The most treacherous metaphors are the ones that seem to work for a time, because they can keep more powerful insights from bubbling up."
    * TODO think about these, particularly about progrmming, but also other fields
  * "The computer field has not yet had its Galileo or Newton or Bach or Beethoven, Shakespeare or Moliere. What is needs first is a William of Occam... Just how many concepts are there really [in computer software]? And how can metaphor, the magical proccess of finding similarity and even identiy in diverse structures, be put to work to reduce complexity?"
  * "In algebra, the concept of the variable, which allows an infinity of instances to be represented and dealt with as one idea, was a staggering advance."
  * ![screenshot 2017-09-01 at 5 17 22 pm](https://user-images.githubusercontent.com/2288939/29988090-7c39ce56-8f39-11e7-87d3-0e52541d1978.png)
    * "Dynamic spreadsheets were invented by Daniel Bricklin and Robert Frankston..."
    * It's crazy how much this picture reminds me of StreamSheets, which was largely inspired by an Alan Kay talk
  * "Users must be able to tailor a system to their waints. Anything less would be as absurd as requiring essays to be formed out of paragraphs that have already been written."
  * ![screenshot 2017-09-01 at 5 34 25 pm](https://user-images.githubusercontent.com/2288939/29988517-e81e1ad0-8f3b-11e7-8331-ea5f84985819.png)
    * A really wonderful discourse on "computer literacy" that reminds me a lot of Chris Granger's "Coding is not the new literacy"

* [The Power Of The Context - 2004](http://www.vpri.org/pdf/m2004001_power.pdf)
  * "About 10 years ago I wrote a history paper about our group's research (available online: see references below) and found, even in 60 pages, I could not come close to mentioning all the relevant influences. This is because I've long been an enthusiastic appreciator of great ideas in many genres—ranging from the graphic, musical and theatrical arts to math, science and engineering."
    * TODO read this history 
  * "My interest in children's education came from a talk by Marvin Minsky, then a visit to Seymour Papert's early classroom experiments with LOGO. Adding in McLuhan led to an analogy to the history of printed books, and the idea of a Dynabook metamedium: a notebook-sized wireless-networked "personal computer for children of all ages". The real printing revolution was a qualitative change in thought and argument that lagged the hardware inventions by almost two centuries. The special quality of computers is their ability to rapidly simulate arbitrary descriptions, and the real computer revolution won't happen until children can learn to read, write, argue and think in this powerful new way. We should all try to make this happen much sooner than 200 or even 20 more years! This got me started designing computer languages and authoring environments for children, and I've been at it ever since. "
  * "The Smalltalk system that I designed, and Dan Ingalls implemented, used an important meta-idea from LISP that allowed its DNA to be completely described on one sheet of paper, implemented in a month, and then grown in the presence of experience and new ideas into the powerful system it became. "
  * Before this article, I thought Seymour Papert and Alan Kay had a baby and it was Mitch Resnick and Scratch. Now I see that it is much more linearly Papert -> Kay -> Resnick.
  * 'it is amazing to me that most of Doug Engelbart's big ideas about "augmenting the collective intelligence of groups working together" have still not taken hold in commercial systems.'
    * TODO look this up
  * TODO organize and pull many of the resources in the notes from this paper into this list of links.

* [The Early History Of Smalltalk](http://worrydream.com/EarlyHistoryOfSmalltalk/)
  * "Small minds try to form religions, the great ones just want better routes up the mountain. Where Newton said he saw further by standing on the shoulders of giants, computer scientists all too often stand on each other's toes. Myopia is still a problem where there are giants' shoulders to stand on—"outsight" is better than insight—but it can be minimized by using glasses whose lenses are highly sensitive to esthetics and criticism."
  * "Programming languages can be categorized in a number of ways: imperative, applicative, logic-based, problem-oriented, etc. But they all seem to be either an "agglutination of features" or a "crystallization of style." COBOL, PL/1, Ada, etc., belong to the first kind; LISP, APL— and Smalltalk—are the second kind. It is probably not an accident that the agglutinative languages all seem to have been instigated by committees, and the crystallization languages by a single person."
  * "Smalltalk's design—and existence—is due to the insight that everything we can describe can be represented by the recursive composition of a single kind of behavioral building block that hides its combination of state and process inside itself and can be dealt with only through the exchange of messages. Philosophically, Smalltalk's objects have much in common with the monads of Leibniz and the notions of 20th century physics and biology. Its way of making objects is quite Platonic in that some of them act as idealizations of concepts—Ideas—from which manifestations can be created. That the Ideas are themselves manifestations (of the Idea-Idea) and that the Idea-Idea is a-kind-of Manifestation-Idea—which is a-kind-of itself, so that the system is completely self-describing— would have been appreciated by Plato as an extremely practical joke."
  * "Though OOP came from many motivations, two were central. The large scale one was to find a better module scheme for complex systems involving hiding of details, and the small scale one was to find a more flexible version of assignment, and then to try to eliminate it altogether. As with most new ideas, it originally happened in isolated fits and starts.""
    * TODO think more on "hiding details", local variables, abstractions and leaks, etc.  
  * "Putting all this together, we want an apparently free environment in which exploration causes desired sequences to happen (Montessori); one that allows kinesthetic, iconic, and symbolic learning—"doing with images makes symbols" (Piaget & Bruner); the user is never trapped in a mode (GRAIL); the magic is embedded in the familiar (Negroponte); and which acts as a magnifying mirror for the user's own intelligence (Coleridge)."
  * "One way to think about progress in software is that a lot of it has been about finding ways to late-bind, then waging campaigns to convince manufacturers to build the ideas into hardware. Early hardware had wired programs and parameters; random access memory was a scheme to late-bind them. Looping and indexing used to be done by address modification in storage; index registers were a way to late-bind. Over the years software designers have found ways to late-bind the locations of computations—this led to base/bounds registers, segment relocation, page MMUs, migratory processes, and so forth. Time-sharing was held back for years because it was "inefficient"— but the manufacturers wouldn't put MMUs on the machines, universities had to do it themselves! Recursion late-binds parameters to procedures, but it took years to get even rudimentary stack mechanisms into CPUs. Most machines still have no support for dynamic allocation and garbage collection and so forth. In short, most hardware designs today are just re-optimizations of moribund architectures."

* [The Center of "Why?" - 2004](http://www.vpri.org/pdf/m2004002_center.pdf)
  * "Still later when I lucked into a terrific grad school at the University of Utah, my first thought was that this was just like 4th grade! And then I realized that Mary Quirk had made 4th grade just like a great graduate school! This is a critical insight. Children are in the same state of not knowing as research scientists. They need to go through many of the same processes of discovery in order to make new ideas their own. Because discovery is really difficult and has taken hundreds of years, the difference is that children have to be scaffolded carefully (but not using the Socratic method, it "leads the witness" too much). Instead the scaffolding has to be set up as close encounters and careful but invisible sequencing to allow the children to make the final leaps themselves. This was the genius of Mary Quirk. It was interesting that we never found out what she knew. She was focused on what we knew and could find out."
  
* ["End-User to the Metal" Personal Computing - Proposal to NSF Granted on August 31, 2006](http://www.vpri.org/pdf/rn2006002_nsfprop.pdf)
  * "We want to be able to do what applications do (and more), but, as with "operating systems", we think there are better paths than the traditional annoying stovepipes that give rise to a few proprietary objects in a way that makes it difficult to combine. Something more like a desktop publishing system that could allow any and all objects to be freely combined visually and behaviorly would be much better. Just as a DTP system allows many different visual elements to be formatted in a wide variety of ways (and master templates made to capture the most useful forms) to cover the entire space of user documents, we would like to go farther in this direction to cover all of the end-user’s needs with a single notion of objects, graphics, user interface, publishing and search. One metaphor that might help (and was an inspiration for many of these ideas) is "HyperCard on Steroids." To do this one would extend HyperCard to have any number of useful objects, allow all to be scripted, and allow the hyperCards to be both full-fledged media pages for docs, web, and presentations, etc., and to recursively be its own embedded media objects."
  *  A newer idea that is moving towards the mainstream is that specifications should be executable and debuggable. We want to go even further to "ship the specifications" – that is, the specifications should not just be a model of the meanings in a system, but should simply be the actual meanings of the systems. This leads to a corollary idea: that we should have an absolute separation of meanings from optimizations" 

* [Inventing Fundamental New Computing Technologies](http://www.vpri.org/html/work/ifnct.htm)


* [Alan Kay Videos](http://www.vpri.org/html/words_links/links_ifnct.htm) 


* [Computers, Networks and Education](http://www.vpri.org/pdf/sci_amer_article.pdf)


* [The Real Computer Revolution Hasn’t Happened Yet - 2007](http://www.vpri.org/pdf/m2007007a_revolution.pdf)


* [STEPS Toward The Reinvention of Programming - 2007](http://www.vpri.org/pdf/tr2007008_steps.pdf)


* [Programming and Programming Languages - 2010](http://www.vpri.org/pdf/rn2010001_programm.pdf)


* [STEPS Toward Espressive Programming Systems, 2011 Progress Report Submitted to the National Science Foundation (NSF) October 2011](http://www.vpri.org/pdf/tr2011004_steps11.pdf)


* [Worlds: Controlling the Scope of Side Effects - 2011](http://www.vpri.org/pdf/tr2011001_final_worlds.pdf)


* [New Etoys](http://www.vpri.org/fonc_wiki/index.php?title=New_Etoys)


* [The Future of Reading Depends on the Future of Learning Difficult to Learn Things - 2013](http://www.vpri.org/pdf/future_of_reading.pdf)
 

* [Stream Processing with a Spreadsheet](https://link.springer.com/chapter/10.1007/978-3-662-44202-9_15)
  * skimmed. the calculus went right over my head

* [A Spreadsheet Model for Handling Streaming Data](https://www.cs.cmu.edu/~shihpinc/pdf/Gneiss-CHI15.pdf)
  * really similar in goals to StreamSheets
  * related work by the author: http://dl.acm.org/citation.cfm?id=2647371

* [SIEUFERD Project (database query tool)](http://people.csail.mit.edu/ebakke/sieuferd/index.html)
  * it's like Looker!

* http://strlen.com/treesheets/
  * watched the intro video with one eye. didn't seem relevant to me now

* Look into Codd's relational calulus and relational algebra
  * seems a little too abstract for me now

* http://witheve.com/
  * http://futureofcoding.org/journal#my-first-full-day-with-eve

* http://scattered-thoughts.net
  * http://scattered-thoughts.net/blog/2015/06/04/three-months-of-rust/
    * Interesting to note that JavaScript might not provide the memory control I need
  * Just bought a dozen books based on his reccomendations
  * http://scattered-thoughts.net/blog/2017/03/16/monolog/
    * Looks like he built a tool to track todos with similar goals to the WoofJS Worflow 
  * http://scattered-thoughts.net/blog/2016/10/11/a-practical-relational-query-compiler-in-500-lines/
    * Seems like building a relational database from scratch is hard and over my head
    * In my gut, I feel like I could just implement all of these things in a super dumb way to start in StreamSheets and if that's too slow I can optimize all this later. 
    * Definitely doesn't feel like something I should figure out now. I should wait until its a more urgent and immediate problem.
    * And it feels like I could just use a JS library or something to hack it for now. These things already exsit.
  * [TodoMVC in Imp](https://github.com/jamii/imp/commit/ea4889010e33a5a522ad2015aff42041c3538139)
    * Reminds me a lot of Eve, which is not a suprise because he worked there
    * Not super intuative to read through on first blush.
    * More of his thoughts on the UI library here: http://scattered-thoughts.net/blog/2017/07/28/relational-ui/ 

* https://github.com/jamii/imp
  * Re-watched [Felienne Hermans "Spreadsheets are code lady" video](https://www.youtube.com/watch?v=TMIBfzSqguQ). Really amazing talk. One insight I had is that if you really want to make spreadsheets more like coding, you need to remove cell references. You can reference columns by their names and rows only by performing operations (filters, finds) on a range of rows. Cell references are the pointers of spreadsheets.
  * [Out of the Tarpit](https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf)
    * the reason "closing and reopening" an app or computer is an effective way to fix things is because the software is mishandling state
    * They made a strong argument in 5.2.4 State and Modularity for no hidden state in components, because it's easy but not simple. (My only worry here is that we're losing abstractive power here because abstraction is all about hiding inner details.)
    * In 7.1 Ideal World... "It is interesting to note that effectively what we have just described is in fact the very essence of declarative programming - i.e. that you need only specify what you require and not how it must be achieved."
    * In 7.1.2 Control in the real world, "Clearly if the progrma is to every run, some control will be needed somewhere because things will have to happen in some order - but this should be nor more our concern than the fact that the changes are elecricity will be needed somewhere." Also: The synchrony hypothesis assumes that all finite and stateless computatinos take zero time so its immaterial whether they happen in sequence or in parallel.
    * 7.2.2 Ease of expression, "One possible sittuation of this kind is for derived data which is dependent upon both a series of user inputs over time, and its own previous values."
  * [The Declarative Imperative](http://db.cs.berkeley.edu/papers/sigrec10-declimperative.pdf)
    * seems really similar in goals to Unison. I wonder if Paul Chiusano has seen http://boom.cs.berkeley.edu/
  * [Imp Journal](http://scattered-thoughts.net/journal/)
  
* http://alarmingdevelopment.org/
  * It's pretty insane reading his "manifesto" how similar his ideas about the future programming are to mine a decade later http://alarmingdevelopment.org/?p=5 and http://alarmingdevelopment.org/?p=6
  * Lol, he referes to a Java Query library called JQuery in 2005, before JQuery is created the following year http://alarmingdevelopment.org/?p=16
  * I really like "no assembly required" as a tagline (instead of no installation necccesary)
  * It's interesting to see how much time he spends talking about the hot new company in this space, Dynamic Aspects, (like I do with Eve), especially because I live in the future and know they amounted to nothing
  * Turns out the idea of state as a reduction of history is an old one: "TeaTime radically unifies data and computation by reducing state to the history of communication. Objects interact solely be sending messages to each other. Objects do not have internal state. Instead, they record the history of all messages they have received. State is an illusion derived from the history of message receipts. Messages sends are a determinstic function of the history of received messages. This is an elegant purification of the original model of Object-Oriented programming, reducing it to the sequenced exchange of messages."
  * he has some interesting but over my head and not super intuative thoughts on branches (if-else) http://www.subtext-lang.org/OOPSLA07.pdf
  * Seems like Jonathan spent a lot of time writing papers and worrying about being accepted. 
  * I really like Alan Kay's idea to rewrite all of programming from the ground up, but I acknowledge that it's probably a bad idea because it's like when developers want to throw out their old code and re-write it but on a massive scale and that's a known bad practice (although, I think it usually works great when going from a bad framework to a good one).  http://alarmingdevelopment.org/?p=229
  * It's amazing and hilarious to see how he jumps around from ideas to ideas, from Subtext to syntax, to no syntax, to front-end, to backend web, etc. Really interesting to see what pulls him in different directions, the conferences he applies to, the trends at the time, the competition, his commentors, etc. It's really impressive and humbling to see how honest and vulnerable he is in these posts. http://alarmingdevelopment.org/?p=319
  * it's funny that he backs his way into a typed version of subtext to avoid things like incompleteness http://alarmingdevelopment.org/?p=351 (http://alarmingdevelopment.org/?p=358) as opposed to liking it for its own advantages like I and other Haskell people do. It feels similar to me when people add types to lamda calculus or set theory to avoid certain paradoxes.
  * A really fun post railing against people who think their langauge (LISP in this case) are annoying http://alarmingdevelopment.org/?p=422
  * "The Apes can’t prove their software is correct, and they seem puzzled by the very idea, as if they were being asked to prove correct a chair." http://alarmingdevelopment.org/?p=440
  * A good argument for 1-indexed arrays http://alarmingdevelopment.org/?p=470
  * References https://www.touchdevelop.com. Neat!
  * What a great quote: "The process of constructing instruction tables should be very fascinating. There need be no real danger of it ever becoming a drudge, for any processes that are quite mechanical may be turned over to the machine itself." – Turing, A. M., 1946, Proposed electronic calculator, report for National Physical Laboratory, Teddington
  * Wow, he also spends a lot of time switching languages and frameworks, from Java, to Scala, and back, to JavaScript, to Dart, etc, etc.
  * Good video discussion the pros/cons of static types and way to overcome them and still get the benefits of static typing while also getting metaprogramming https://vimeo.com/74314050

* http://www.expressionsofchange.org/
  * Undo could definitely be made more powerful http://www.expressionsofchange.org/the-power-of-undo/
  * Software changes over time are more complex than I thought. For example, database schema migrations, software packages and dependencies, build tools and containers
  * In order to truly have the expressiveness we want (and other expressiveness we don't even know we want yet), we need to have really composable abstractions about code changes. They must be a first class datatype. (If the code is really just a reduction of all changes, we have a ton of flexibility here.)
  * The ability to "copy and paste" a set of changes to your code is paramount. This is one of the main successes of the command line and failures of GUIs. Point and click is so damn imperative and full of side effects. We really have to get meta fast if we want our GUI to be as powerful as the command line.

* https://github.com/viskell/viskell
  * haskell programming as a graph
  * I don't usually find graphs compelling. I prefer blocks/structured editor approaches which leave the text closer to prose sentences for better reading. I'm not a computer so I don't like reading trees.

* [Conal Elliot - Tangible Functional Programming](https://www.youtube.com/watch?v=faJ8N0giqzw)
  * the dream: combine usability and composability (so like IFFT but at the right level of abstraction)
  * UNIX pipes with input and output text makes it easy to compose
  * I've already seen this video, I'm now realizing, he shows how to drag outputs into inputs in a GUI

* [Conal Elliot - Fran - Composing Reactive Animations](http://conal.net/fran/tutorial.htm)
  * Holy shit! This is like Reactive WoofJS (or the Elm game engine) but was made in 1998 in Haskell! He makes quick work of my "inital value problem": simply give a function all the arugments it needs, starting value, and rate of increase
  * Let me send this over to my friends at McMaster University to see if they've thought about making an Elm version...

* [Conal Elliott - The Essence and Origins of Functional Reactive Programming](https://www.youtube.com/watch?v=j3Q32brCUAI)
  * seperate design spec from implementation
  * FRP is about continuous time in the same way vector graphics are about continuous space
  
* [Conal Elliot - Denotational Design](http://conal.net/papers/type-class-morphisms/)
  * "The purpose of abstraction is not to be vauge but to create a new semantic level in which one can be absolutely precise." - Dijkstra
  * Peter Landin reccomends that "denotive" to replace ill-defined "functional" and "declarative". A langauge is only "denotive" if each expression only depends on sub-expressions
  * before you think about implementation... what are the main types, main operations, what do the types mean?
  * for example, an image is an assignment of colors to 2D locations
  * Turns out Images and Colors are Monads... I should probably understand Applicative, Functor, Monoids, and Monads more
  * I can't get one of his quotes out of my mind. He says that if we do it right, our abstractions will constrain us and disable us from getting certain kinds of information or doing certain things, such as counting how many computation took place on a given image. Part of me likes this non-leaky abstraction but part of me worries that it would be too constraining, and it makes me wonder if there's a middle ground somehow. I feel emotionally that if we had enough self-resembalance and designed our programming language in itself, we might be able to do it.
  
* [Luke Palmer - Semantic Design](https://lukepalmer.wordpress.com/2008/07/18/semantic-design/)
  * references Conal Elliott's work a lot
  * talks about picking the right abstraction and encoding it into types (similar to my idea to kill booleans)

* [Luke Palmer - The purpose of code is to be abstracted over](https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/#comment-1017)


* [Loper OS](http://www.loper-os.org/?p=861)
  * I disagree. I think emacs represents the wrong model: spend a few hundred hours learning this system and we'll improve your brain-computer interface. Instead, why don't we 1) get better abstractions so we have less work (like Paul Chiusano says) and 2) build a more intuiative interface for everyone? 

* [Flowsheets](http://tinyletter.com/Flowsheets/letters/flowsheets-visualizations)
  * neat spreadsheet like interface for python computations

* [Ken Perlin on Chalktalk](https://www.youtube.com/watch?v=xuzrF_82z7U)
  * professor at NYU
  * making magic real with AR/VR. A combo of harold with a crayon and harry potter
  * he has a really interesting medium like Ivan Sutherland's Sketchpad that allows you to create and link together dynamic diagrams. It feels too good to be true, like it was over optimized for this one presentation. I want to see the code on github 
  
* [Jonathan Edwards: Two-way Dataflow](https://vimeo.com/97684085)
  * looks like this turned into [Chorus](http://www.chorus-home.org/)
  * his todomvc example isn't half bad, although I think the react, one-way databinding way that Cycle v2 uses is more in style these days
  * seems like Lamdu does a good job of implementing [his vision for easy-to-use static typing]https://vimeo.com/74314050)
  
* [Francisco Sant’Anna: Dynamic Organisms in Céu](https://vimeo.com/97687022)
  * seems similar to my idea of making a reactive version of Woof or an Elm game engine
  
* [Patrick Dubroy: Moonchild](https://vimeo.com/97711824)
  * I've seen this before. Neat project
  * Allow you to incrementally turn a code editor into a GUI editor, with things like color pickers. It'd be neat if we had this on woofjs.com, so students could see the color in their code and use the color picker right there.
  
* [Mark Mahoney: Version Control Optimized for Teaching and Learning](https://vimeo.com/97711978)
  * it's like seperate conversations for every change of code. So it's like github pull request reviews but on steriods.
  * You can get character by character playback, so it's very much like google docs in that way
  * I admire his goal -- enhancing commit log and explaining code and evolution of system
  * This is related to my idea of putting the commit message first, reversing things, but in a much better and granular way. TODO write up my thoughts here, particularly how you can nest things in a workflowy style
  * wouldn't it be neat if you could query by certain kinds of changes, like adding regex's

* [Bill Burdick: Leisure](https://vimeo.com/97713914)
  * blurs the line between viewing and editing websites
  * "brings the chrome inspector more center stage"
  
* [David Broderick: Kaya: Declarative Reactive](https://vimeo.com/97712270)
  * seems like he'd be a fan of Eve
  
* https://github.com/lamdu/lamdu/
  * really wonderful explaination of many of hte main points of my thesis http://www.lamdu.org/ and https://medium.com/lamdu-blog/designing-programming-languages-with-ides-in-mind-de890989dfa
  * while I still don't really understand even what I'm installing (is it a terminal app or a GUI app), it took me over an hour to install Lamdu on Cloud9, fighting with apt-get, stack, and generally waiting for everything to download and install. Clearly they don't have a sufficient appreciate of the cloud-based nature part of my thesis.
  * I found this wonderful video showing it in action https://vimeo.com/97713439. This video is like Paul's early demo's of Unison but more extensive! I'm blown away. I can't believe I didn't find this sooner. I want to submit a pull request to get them to put this video on their main page. Ok, just did... https://github.com/lamdu/lamdu.github.io/pull/5
  * it's been hours and things still aren't done installing... just updated my c9 instance to have the max RAM and memory
  * More research in my journal here http://futureofcoding.org/journal#july-24-2017-204pm
  * My final notes on Lamdu in my journal here: http://futureofcoding.org/journal#july-25-2017-226pm
  
* [A brief history of "type"](http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html?m=1)

* [Intentional Programming](https://en.wikipedia.org/wiki/Intentional_programming)
  * I think this stuff is really interesting. If done right, it's similar to how google wants all of their code to be self-documenting. It's probably the exact opposite of Eve's literate programming approach where the code and explaination are two seperate things that humans need to keep in sync.
  * Personally, I find functional programming hard to read / parse meaning from. TODO think about ways we could make FP more readable
  * TODO think about what it would be like to define an entire program in a high-level language and then have to specific the macros to intepret each expression, potentially with Woof. Think about how to zoom in and out on various lines.

* https://en.wikipedia.org/wiki/Deutsch_limit
  * not to be taken seriously. at a worst case, we can put text into visual programming to add density, but density isn't that important after all because we have encapsulation.

* [Additional Notes on "Drawing Dynamic Visualizations"](http://worrydream.com/DrawingDynamicVisualizationsTalkAddendum/)
  * really amazing, inspirational demos! Makes me wonder how Scratch could be more like this and less about the code
    * TODO brainstorm what would be a intuative interface for a student to program gravity from scratch
  * Seems similar to aprt.us, which makes sense because Bret steals from Toby's Recursive Drawing project
  * TODO think about ways to tackle the context problem, helping programmers point to what they want

* [How to Invent the Future II - Alan Kay](https://www.startupschool.org/videos/12)  

* [Alan Kay - how to invent the future pdf](https://www.dropbox.com/s/l4qnf40gksapsrl/Alan%20Kay%20-%20How%20to%20Invent%20the%20Future.pdf?dl=0)

* [Alan Kay - Power of Context](https://www.dropbox.com/s/knngq11tzdi0tdh/Alan%20Kay%20-%20The%20Power%20of%20the%20Context.pdf?dl=0)

* [Always bet on text](http://graydon.livejournal.com/196162.html)
  * text is great for many reasons. I think less so for communicating with comptuers

* [How to Invent the Future I - Alan Kay](https://www.startupschool.org/videos/11) 
  * email him - he loves email!
  * read "the dream machine" about xerox parc / arpa
  * sketchpad is interesting. does object-oriented programming well: master vs instances
    * read ivan sutherland 1962 thesis - man machine communication thesis
  * really great advise on running research community
    * vision, not goals
    * fund people, not projects
    * research community, not research project
    * fund problem finding, not just problem solving
    * milestones, not deadlines
    * be ok with high failure rate
    * just two years for the person running the group
    * solve the problem, don't think about what you can do with the tools you have. make the tools if you need to
    * argue for clarity, not to win
    * keep tabs on people in the "minor leagues"
  * send alan kay about email about learning to communicate with Aliens from integalactic email memo from "Lick"

* Elm
* Hopscotch
* App Lab
* App Inventor
* Bubble.is
* Aprt.us
* http://cirru.org/
* Unison
* http://www.vpri.org/pdf/tr2011001_final_worlds.pdf
* Blockly
* Zapier
* IFFT
* http://origami.design/tutorials/getting-started/Getting-Started.html
* FramerJS
* [Lisp, Smalltalk, and the power of symmetry](https://insearchofsecrets.com/2014/08/04/lisp-smalltalk-and-the-power-of-symmetry/)
* https://medium.com/@stevekrouse/resources-for-creating-front-end-programming-languages-and-frameworks-in-2017-a0c097625f9d

## Where to Find More Links

* http://worrydream.com/dbx/
* http://pgbovine.net/human-centered-programming-tools.htm
* http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/
* http://www.squeakland.org/resources/books/readingList.jsp
* http://worrydream.com

  <script>
  
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-103157758-1', 'auto');
  ga('send', 'pageview');

  </script>
