---
title: Link Research
---

# Link Research

## To Research

* https://github.com/lamdu/lamdu/
* https://github.com/jamii/imp
* http://witheve.com/
* http://www.luna-lang.org/

### Unordered

* http://worrydream.com/substroke/
* PureScript
* http://www.eff-lang.org/
* https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/TFM.pdf
* Idris
* http://conal.net/papers/Eros/
* http://tinyletter.com/Flowsheets/
* http://shaunlebron.github.io/parinfer/
* https://www.sourcetrail.com/
* Kite.com
* http://www.clickteam.com/multimedia-fusion-2
* Unity
* https://www.scirra.com/construct2
* https://www.hyperpad.com/
* Thunkable
* https://powerapps.microsoft.com/en-us/
* http://www.ragic.com/
* http://www.chorus-home.org/
* Jet Brains MPS
* http://www.greenfoot.org/frames/
* http://flowlab.io
* http://embrio.io/
* http://harc.ycr.org/project/gp/
* [Tulip](https://www.youtube.com/watch?v=lvclTCDeIsY)
* https://www.pipes.digital/
* https://www.theatlantic.com/magazine/archive/1945/07/as-we-may-think/303881/
* http://www.memex.org/licklider.pdf
* http://web.media.mit.edu/~minsky/papers/TuringLecture/TuringLecture.html
* [Computer as Communications Device](https://www.dropbox.com/s/4td8aj5gglf4qfj/The%20Computer%20As%20A%20Communications%20Device.pdf?dl=0)
* http://www.red-lang.org/p/about.html
* https://cospaces.io/edu/
* Lively Kernal
* [Seymour Papert On Logo](http://el.media.mit.edu/logo-foundation/resources/onlogo/index.html)

## Researched

* [A brief history of "type"](http://arcanesentiment.blogspot.com/2015/01/a-brief-history-of-type.html?m=1)
* [Intentional Programming](https://en.wikipedia.org/wiki/Intentional_programming)
  * I think this stuff is really interesting. If done right, it's similar to how google wants all of their code to be self-documenting. It's probably the exact opposite of Eve's literate programming approach where the code and explaination are two seperate things that humans need to keep in sync.
  * Personally, I find functional programming hard to read / parse meaning from. TODO think about ways we could make FP more readable
  * TODO think about what it would be like to define an entire program in a high-level language and then have to specific the macros to intepret each expression, potentially with Woof. Think about how to zoom in and out on various lines.
* https://en.wikipedia.org/wiki/Deutsch_limit
  * not to be taken seriously. at a worst case, we can put text into visual programming to add density, but density isn't that important after all because we have encapsulation.
* [Additional Notes on "Drawing Dynamic Visualizations"](http://worrydream.com/DrawingDynamicVisualizationsTalkAddendum/)
  * really amazing, inspirational demos! Makes me wonder how Scratch could be more like this and less about the code
    * TODO brainstorm what would be a intuative interface for a student to program gravity from scratch
  * Seems similar to aprt.us, which makes sense because Bret steals from Toby's Recursive Drawing project
  * TODO think about ways to tackle the context problem, helping programmers point to what they want
  * 
* [How to Invent the Future II - Alan Kay](https://www.startupschool.org/videos/12)  
* [Alan Kay - how to invent the future pdf](https://www.dropbox.com/s/l4qnf40gksapsrl/Alan%20Kay%20-%20How%20to%20Invent%20the%20Future.pdf?dl=0)
* [Alan Kay - Power of Context](https://www.dropbox.com/s/knngq11tzdi0tdh/Alan%20Kay%20-%20The%20Power%20of%20the%20Context.pdf?dl=0)
* [Always bet on text](http://graydon.livejournal.com/196162.html)
  * text is great for many reasons. I think less so for communicating with comptuers
* [How to Invent the Future I - Alan Kay](https://www.startupschool.org/videos/11) 
  * email him - he loves email!
  * read "the dream machine" about xerox parc / arpa
  * sketchpad is interesting. does object-oriented programming well: master vs instances
    * read ivan sutherland 1962 thesis - man machine communication thesis
  * really great advise on running research community
    * vision, not goals
    * fund people, not projects
    * research community, not research project
    * fund problem finding, not just problem solving
    * milestones, not deadlines
    * be ok with high failure rate
    * just two years for the person running the group
    * solve the problem, don't think about what you can do with the tools you have. make the tools if you need to
    * argue for clarity, not to win
    * keep tabs on people in the "minor leagues"
  * send alan kay about email about learning to communicate with Aliens from integalactic email memo from "Lick"
* Elm
* Hopscotch
* App Lab
* App Inventor
* Bubble.is
* Aprt.us
* http://cirru.org/
* Unison
* http://www.vpri.org/pdf/tr2011001_final_worlds.pdf
* Blockly
* Zapier
* IFFT
* http://origami.design/tutorials/getting-started/Getting-Started.html
* FramerJS
* [Lisp, Smalltalk, and the power of symmetry](https://insearchofsecrets.com/2014/08/04/lisp-smalltalk-and-the-power-of-symmetry/)
* https://medium.com/@stevekrouse/resources-for-creating-front-end-programming-languages-and-frameworks-in-2017-a0c097625f9d

## Where to Find More Links

* http://worrydream.com/dbx/
* http://pgbovine.net/human-centered-programming-tools.htm
* http://blog.interfacevision.com/design/design-visual-progarmming-languages-snapshots/
* http://www.squeakland.org/resources/books/readingList.jsp
* worrydream.com
