---
title: 33 - Reflection 14 - about
---

# #33 - Reflection 14: /about

_08/24/18-10/28/18_

If you haven't been following my research journey, this episode is a great place to join! I recap who I am, where I come from, what I'm trying to accomplish, and how I hope to accomplish it.

The mission of this project is, broadly, to "democratize" programming. My new phrase is:

**Enable all people to modify they software they use in the course of using it.**

This mission would cause the following changes, in order of increasing importance:

1. All software will be co-created by decentralized communities, rather than centralized groups or companies.
2. Through the power of crowd-sourcing, the quality of all software will become much higher than existing software.
3. All software will be much more composible, interoperable with other pieces of software.
4. All software will be arbitrarily customizable, allowing for bespoke, tailored experiences.
5. Learning to communicate with computers teaches one how to think more clearly, precisely, mathmatically, and powerfully. If one can manipulate the software one uses, if only one learns how to organize one’s thoughts, many people will self-teach themselvse to do just that.
6. As the fabric of the world is eaten by software, the ability to fully manipulate that software one uses is an essential freedom.

This vision is not new nor creative: it’s obvious that people would change things if they could. Yet this problem has proven stubborn over the decades and most have given it up as insoluble. We have all but forgotten the essential characteristic of computers: their malleability.

In order to accomplish this vision, I believe there are three large categories of problems that need to be addressed:

1. **Rid ourselves of the IO Monad**, replacing it with better abstractions for whole systems.
2. Create a better **programming experience** for the complex abstractions we create to avoid IO.
3. Reimagine **version control** for a world where software looks very different than it does today, with many, many more forks, at many more levels than just one-deep off of master.

My recent work was on ridding ourselves of the IO Monad from user interfaces, which is building on Conal Elliot's FRP work. [My paper and talk](http://futureofcoding.org/papers/comprehensible-frp) at REBLS last month argues that Elm Architecture makes software take longer to understand (which is untenable if we want people to be able to modify the software they use *in the course of using it*) as compared to the higher-order and cyclic streams of Conal's original FRP.

My future work will be improving the programming experience of "original FRP", potentially with a Haskell-inspired structured editor. I will also extend Conal's FRP work to also [removing the IO Monad from the "backend"](https://github.com/stevekrouse/futureofcoding.org/issues/85).

In the episode I add a lot more color to these points, as well as discuss my personal background, the past and future of Future of Coding meetups, my experience at SPLASH last month, and other whacky ideas! 

<iframe src="https://omny.fm/shows/future-of-coding/33-reflection-14-about-1/embed?style=cover" width="100%" height="180" frameborder="0"></iframe>

## Transcript

_Transcript sponsored by [repl.it](https://repl.it/)_

<style>
  .name {
    display: inline-block;
    margin-right: 5px;
    font-weight: bold;
  }
  .time {
    display: inline-block;
    margin-right: 5px;
    font-size: 12px;
    color: grey;
  }
  .time:hover {
    text-decoration: underline;
   }
  .block {
   padding: 10px; 
  }
</style>

<div id="transcript">
	<!-- generated at https://regexr.com/447hg-->
	<!-- and then https://regexr.com/447hj -->
	<div class="block">
		<div class="time">00:00:00</div>
		<div class="name">SK:</div>Hello and welcome to the Future of Coding. This is Steve Krouse. So welcome to reflection 14, where I talk about basically how my last three months of research have went. The last episode reflection I did was on August 24th, so this one
        is for the end of August, all of September, October, and all of November until today, which is basically the end of November, of 2018 for those of you who are tuning in to this episode far into the future.
	</div>
	<div class="block">
		<div class="time">00:00:34</div>
		<div class="name">SK:</div>And now a message from our sponsor. Repl.it is an online REPL for over 30 languages. It started out as a code playground, but now it scales up to a full development environment, where you can do everything from deploying web servers to
        training ML models, all driven by the REPL. They're a small startup in San Francisco, but they reach millions of programmers, students and teachers. They're looking for hackers interested in a future of coding and making software tools more accessible
        and enjoyable, so email jobs@repl.it, R-E-P-L dot I-T, if you're interested in learning more.
	</div>
	<div class="block">
		<div class="time">00:01:06</div>
		<div class="name">SK:</div>Okay, so it has been a really great three months. Instead of going through the three months chronologically, I'm going to start with my new about page, futureofcoding.org/about, and I'm going to mostly just read it and have a few side
        notes as they come up. All right, so about futureofcoding.org. TLDR, Future of Coding is a research project and podcast by me, Steve Krouse. My research is focused on building an open-source programming language. The podcast alternates between
        interviews with programming language experts and reflections on my own research journey.
	</div>
	<div class="block">
		<div class="time">00:01:52</div>
		<div class="name">SK:</div>Me. Hi, my name is Steve Krouse. When I meet people, I like to begin with life stories. Context is important. Here's mine as it relates to this project. I was born in New York City in 1994 and raised in South Florida. As a kid, I was
        bad at school, and particularly, bad at math. However, I was also a computer kid, and partly because of that, I started going to a wonderful afterschool computer science program, IMAX. Through learning Logo, Scheme, Java, and Haskell in middle
        and early high school, at IMAX's self-paced and nurturing environment, I became a computational, mathematical and introspective thinker. I became very good at school, especially mathematics and physics.
	</div>
	<div class="block">
		<div class="time">00:02:44</div>
		<div class="name">SK:</div>I went to the University of Pennsylvania for college. After taking most of the computer science classes at Penn, I left without graduating in early 2014 and went to work at Looker. I left looker at the end of 2014. While at college and
        Looker I was deeply influenced by Bret Victor and Seymour Papert. Ever since my experience of transforming from a self-identified stupid person to a self-identified smart person in middle school, I was curious about how it happened and if similar
        changes could be nurtured in others. While reading Seymour Papert in college, I learned that my own transformation was no accident. Papert intentionally set out to create mathematical thinkers from math-phobes, with Logo, and he accomplished his
        goal in me. It was a really mind-bending experience, reading Papert in college and realizing that the changes he caused in me were on purpose. He spoke about his motivations for creating Logo, the design choices he made in designing Logo, and
        then he would tell stories about how Logo affected children, and I would remember similar experiences from my own childhood, and I could recall how those experiences helped me in life.
	</div>
	<div class="block">
		<div class="time">00:04:03</div>
		<div class="name">SK:</div>So with these thoughts in mind, in July 2015, I co-founded The Coding Space in a New York city based afterschool program, where we taught kids to code in a self-paced environment, in a very similar spirit to IMAX. There, I created our
        Scratch-based curriculum as well as WoofJS, which is a JavaScript framework and online IDE built to transition kids from Scratch to JavaScript. So the idea behind Woof is that for every block in Scratch, there's an equivalent command and JavaScript,
        so kids who know Scratch well can leverage their existing Scratch knowledge while learning JavaScript syntax. And I think this is a much better transition, curricular progression as opposed to starting in a text-based language and having to learn
        both concepts and syntax at the same time. I think it's better to start with the concepts, and then layer on syntax once the student is familiar with basic constructs such as variables, loops, Booleans, ifs, branches, et cetera.
	</div>
	<div class="block">
		<div class="time">00:05:05</div>
		<div class="name">SK:</div>So in mid-2017, I left The Coding Space to work on programming languages full time. Now, so at first, I thought I'd have this whole thing solved in just a matter of months all by myself. I have this brand-new programming language and
        everything will be great. I was wrong. While I did make some interesting prototypes in the first few months, or year, or so, I spent most of my time retracing the steps of those that came before me. I learned the hard way that I need to read my
        history. Then in the summer of 2017, I was approached by Irvin Hwang, who suggested starting a New York city based meetup group for people interested in the future of programming. Now, I thought that was the dumbest idea I had ever heard. Why
        waste my time talking to other people when I could read Alan Kay papers in my room? But he, despite my misgivings, organized our first meeting, and I went, and it blew my mind wide open.
	</div>
	<div class="block">
		<div class="time">00:06:07</div>
		<div class="name">SK:</div>I learned so much in that hour. It's astounding. It inspired my log, futureofcoding.org/log, which has since become the core of my research practice. I put all my research notes in it, in like a effort of radical transparency. And I learned
        many other things and met some really wonderful friends that I'm still friends with to this day at just that initial meeting. So, after Irvin became busy with his new job, I took over the group and created a Slack for Future of Programming folks,
        which is now used by people all over the world and we're having meetups pop up in various places, which is really cool. So, I learned the easy way the importance of community. Thank you, Irvin. It was also around this time that I began this podcast,
        which alternates between recapping my own research, as I'm doing now, and speaking with experts.
	</div>
	<div class="block">
		<div class="time">00:07:05</div>
		<div class="name">SK:</div>It's been incredibly valuable. It's been an incredibly invaluable experience for me, helping to add structure to my research, gaining new insights through collaboration, encouraging me to reflect on my progress, and giving me energy as
        people like you respond to episodes, on Twitter, in email, in Slack, with excitement and ideas of their own. My framing for this project has gone through a number of turbulent stages, Bret Victor wannabe, total disheartenment, irrational exuberance,
        et cetera, et cetera, but I have recently, as a fall 2018, come to a very positive mental space, which I'll describe in a sec. These days, I describe myself as a programming language designer, because my goal is to create a working system, not
        just produce research, that resembles a programming language in its expressive power, but we'll feel more like a system in the Excel or Smalltalk sense, than a text-and-compiler-based programming language.
	</div>
	<div class="block">
		<div class="time">00:08:04</div>
		<div class="name">SK:</div>Okay, my mission. The mission of this project is to enable all people to modify the software they use in the course of using it. Now, just a quick caveat, I have a note on this page, that when I say all people, I guess I don't really
        need a 100% of people, because even today, not 100% of people in the world can read and write. Not even a 100% of people will know how to use a computer or a smart phone. I guess I'm talking about a lot more, like maybe 90% of people will have
        the ability if they so choose, or whatever. Maybe 90% of people who know how to use computers. Basically, a lot. Virtually everyone, everyone you know, anyone listening to this podcast, any of your friends and family, especially people of a younger
        generation. I don't know about the older generation.
	</div>
	<div class="block">
		<div class="time">00:09:00</div>
		<div class="name">SK:</div>Anyways, when I say all people, that phrase that needs to be pinned down more. I need more nuance there, but directionally, I mean a lot more people than now, like order of magnitudes more people. So, like maybe 100 times or 1,000 times,
        or 10,000 times. Well actually, if you think about it, let me read the mission again. The mission of this project is to enable all people to modify the software they use in the course of using it. So, how many people do you know that modify the
        software they use in the course of using it? I think the answer is basically zero. Maybe there are few people who have side projects that they also use on a daily basis, and maybe they're modifying their side projects while they're using them.
        I've done that a handful of times, but on the whole nobody does this. So we want this number to look more like millions of people. Maybe it's not billions but at least millions.
	</div>
	<div class="block">
		<div class="time">00:09:53</div>
		<div class="name">SK:</div>All right, so here's why this mission is important, and I'm going to list six reasons, and the sixth is the most important. The first is the least important. So number one, all software will be co-created by decentralized communities,
        rather than centralized groups or companies. Number two, through the power of crowdsourcing, the quality of all software will become much higher than existing software, so this is just drawing right on Wikipedia's success. Number three, all software
        will become more composable and interoperable with other pieces of software.
	</div>
	<div class="block">
		<div class="time">00:10:30</div>
		<div class="name">SK:</div>Number four, all software will be arbitrarily customizable, allowing for bespoke tailored experiences, and so I spoke ... Number two was that the quality of software would become better, and I think that will be true in an absolute sense,
        but I think more importantly, software will become better because it would be more what you want. You'll have the power to customize it to be exactly what you want, and not only will the quality be better, because you've made it exactly what you
        want it to be, but you will have the sense of self-sufficiency. You'll have this sense of power, autonomy, which really is priceless.
	</div>
	<div class="block">
		<div class="time">00:11:10</div>
		<div class="name">SK:</div>Number five, learning to communicate with computers teaches one how to think more clearly, precisely, mathematically, and powerfully. If one can manipulate the software that one uses, only if one learns how to organize one's thoughts,
        many people will take the bait and will self-teach themselves to code in order to have power over their computer, their virtual world. This is kind of a little bit of a paternalistic goal, so I have mixed feelings about having goals like this,
        bait-and-switch goals, but given my background, and how my life was changed by learning to code, it's very motivating for me to build a system that will entice others to learn how to code.
	</div>
	<div class="block">
		<div class="time">00:11:55</div>
		<div class="name">SK:</div>And the goal here, to be clear, is not that I want more people to learn how to code. The main thing with this one is I want them to learn how to think clearly. I also want them to have autonomy over their computers. I don't care about
        them building apps so they can go make millions. I want them to have control over their virtual worlds. And that's number six. As the fabric of the world is eaten by software, the ability to fully manipulate that software is an essential freedom,
        particularly the software that one uses on a daily basis.
	</div>
	<div class="block">
		<div class="time">00:12:29</div>
		<div class="name">SK:</div>All right, so now this vision is not new, nor is it creative. It's obvious that people would change things about their software if they could. Yet because this problem has proven stubborn over the decades, most have given it up as insoluble,
        most computer scientists, but particularly most laypeople. We have all but forgotten the essential characteristic of our computers, their malleability. We look at computers and the apps we use as being rigid and out of our control, just like the
        laws of gravity are out of our control. When was the last time you thought, "I wonder what would it be like if gravity was a little bit stronger, or a little bit weaker. Or the strong nuclear force, I wonder what the world will look like if I
        tweaked that a bit." You never wonder those thoughts, because you know you have no control over them.
	</div>
	<div class="block">
		<div class="time">00:13:16</div>
		<div class="name">SK:</div>And similarly, you've never wondered ... Well, maybe those of you listening to this podcast have, but most people, 99.9% of people, haven't really wondered that much, about how to change the software they use, because they know they have
        no power over it. We've forgotten that computers can be anything we imagined them to be. Part of why I say this is because when I tell people what I'm building, and why I'm building it, they aren't that ... Laypeople aren't that excited. Sometimes
        they'll say, "You know, I just want things to be simple. I don't really care about customizing things." And this makes me think of how people don't always want democracy. They don't always want the right to vote.
	</div>
	<div class="block">
		<div class="time">00:13:56</div>
		<div class="name">SK:</div>I remember reading like a history of the suffrage movement, women's suffrage movement, and I was shocked to learn that the early suffragettes had to convince women that they wanted the right to vote. It wasn't like a natural thing to
        want, and I think that the same is true here. It's not fully a natural thing to want something that you can't imagine having, but that doesn't mean we shouldn't fight for people's right to have it.
	</div>
	<div class="block">
		<div class="time">00:14:29</div>
		<div class="name">SK:</div>Alright. So, now my thesis. My current angle on this whole mission is most influenced by Jonathan Edwards, Out of the Tarpit, Conal Elliot, Bret Victor, and Paul Chiusano. There are many, many, many hundreds of others who have influenced
        my thinking here, but I don't want to list them all. Those are the people that really come top of mind when I think about where my thoughts come from, particularly not only on the inspiration for the mission itself, but for how to achieve it.
	</div>
	<div class="block">
		<div class="time">00:15:05</div>
		<div class="name">SK:</div>All right, so my thesis. Number one, the comprehensibility of large software is of utmost importance. So, the mission is that you should be able to modify the software you use on a daily basis, in the course of using the software. If
        we're gonna make that true, what needs to happen is that when you want to make a change to a piece of your software, you have to be able to understand exactly what's going on in the code underlying that software as fast as possible, so you can
        make the change and then get back to whatever it was that you were doing. I'm envisioning kind of like you're driving your car, you pop the trunk, you make the change, you get back in your car. It's not a great metaphor, because cars are kind
        of hard to understand, but just bear with me. Pop the trunk, tweak, pop the trunk back down, drive off in the car. So, let's just talk about comprehensibility for a second, and why it's so bad.
	</div>
	<div class="block">
		<div class="time">00:16:09</div>
		<div class="name">SK:</div>Have you ever, as a programmer, been working on an open-source project and wanted to contribute in some way? Maybe you found a bug, something else, who knows? You want to make little contributions to the code, not just the documentation.
        So, you download the repository. You figure out the build script. You probably just quit after you try installing it, and it breaks because of some dependency it was missing, or some incompatibility. Who knows? So the whole build thing is annoying.
        Getting the code to run is annoying. But then, you do all that, and you try to understand the code, and even if it's just 1,000 lines of code. If it's more than 100 lines of code, you're basically screwed. 500 lines of code, it's going to take
        you so many hours to understand how that code works that, again, you're just going to give up.
	</div>
	<div class="block">
		<div class="time">00:17:03</div>
		<div class="name">SK:</div>So, that's why comprehensibility is so important, because our code ... In order to make a change to an app that I use every day, I'm going to have to understand not only 500 lines of code, but probably hundreds of thousands of lines of
        code. Like, Microsoft Word is millions, millions of lines of code. So, the comprehensibility of large software projects is critical if we want to achieve this mission, and now maybe, after you've heard me describe how hard it is to understand
        an unfamiliar codebase, you think that, you know, "Let's just give up. This is impossible," but I don't think so. I think as long as we keep our eye on the ball of comprehensibility, we should be fine.
	</div>
	<div class="block">
		<div class="time">00:17:43</div>
		<div class="name">SK:</div>Okay, so point two. In order to enable comprehensibility, without sacrificing expressivity, we must strive to eliminate all forms of incidental complexity in programming. Programming should describe the essential nature of the problem,
        the view from the user, if only the user were made to see the implication of all things. Okay, so now this is a really important point, but it's a little bit hand-wavy. I'm getting this incidental and essential complexity initially from Fred Brooks,
        but it's also referenced in Out of the Tarpit.
	</div>
	<div class="block">
		<div class="time">00:18:22</div>
		<div class="name">SK:</div>All right, so point three is also a little bit hand-wavy. Mathematics is the language of essence, or as close as we can get. If you have something better, let's talk about it. But math is pretty good. Something like the lambda calculus
        is pretty much as close as we can get to the language of pure computation free of mechanical and historical accidents. Again, I'd be open to alternatives. The lambda calculus is also seems kind of random, but it's the best I can think of that
        represents essential natures of computation.
	</div>
	<div class="block">
		<div class="time">00:19:07</div>
		<div class="name">SK:</div>Okay, so number four. The solution is to create denotative languages, or a denotative language, a language where each term denotes an equivalent mathematical object. So in other words, basically what I'm getting at is we need to, point
        five, rid ourselves of the IO monad and replace it with better abstractions for whole systems. So, now Conal Elliot has a really, really wonderful post, Will Functional Programming Ever be Liberated From the von Neumann Architecture? In this point,
        he makes a really, really wonderful distinction.
	</div>
	<div class="block">
		<div class="time">00:19:43</div>
		<div class="name">SK:</div>So, monads themselves are this very benign type class thing with laws. They're kind of mathematical and categorical. They're great, and they're not that hard to understand. The thing that's kind of hard to understand, I think, is the
        IO monad. And I think part of why it's hard to understand is that Haskell people aren't honest about what it is. The IO monad is imperative code embedded within Haskell. That's what it is. You get to write code with side effects within your Haskell
        program. And it's a reasonable compromise given the world we live in today, because you want to have the benefits of Haskell, but then you also need your code to have some side effects.
	</div>
	<div class="block">
		<div class="time">00:20:24</div>
		<div class="name">SK:</div>But Conal Elliot shows us how we can do better than the IO monad, and he showed how with FRP. Functional reactive programming, he argues, and I would agree, is a way to do side effect-y things. Basically, you have a user interface on
        the screen, that a user can interact with, and it can be dynamic, and update, and whatnot, so there are all these side effect-y things happening, your computer doing stuff, yet the interface, to the programmer, at the Haskell level, or at the
        FRP level, has no IO. You describe the view as a pure function of state. It's beautiful. It's a beautiful system.
	</div>
	<div class="block">
		<div class="time">00:21:03</div>
		<div class="name">SK:</div>So, this essay argues that we should be able to extend that idea of getting rid of the IO monad and replacing it with better abstractions for whole systems to the entire world of programming. This is pretty wacky, and I don't know ...
        I think most Haskell people, functional programming people won't agree with this vision, but I'm really excited about it, so FRP is all about removing the IO monad from user interface construction, but then what about all the rest of programming?
	</div>
	<div class="block">
		<div class="time">00:21:35</div>
		<div class="name">SK:</div>So, we have the backend, for example. We have databases. We have file systems, sockets, all that stuff. Okay, so now here's the key idea. There are a lot of things that programming languages deal with now that they shouldn't deal with.
        They're too low level. So, just for an analogy, think about FRP. Before FRP, we used jQuery. Before React, for example, you used jQuery to manually mutate the DOM, manually mutate the HTML on your websites, piece by piece. But now, with React,
        you simply say what you want the HTML to look like at any given point in time, given a state, and boom, it does a jQuery for you, automatically, so you don't have to dirty your hands with the IO monad, with mutability. You can just declaratively
        say what you want, and it's a computer's job to figure it out, and in React's case, it does it with diffing the DOM tree to figure out the minimal set of jQuery changes it needs to make in order to get the page to look like how you want.
	</div>
	<div class="block">
		<div class="time">00:22:40</div>
		<div class="name">SK:</div>So now let's apply that same kind of thinking to every other part of programming. Many parts of what programming does isn't necessary. So, putting things to the console, getting characters from the console, writing the file system, opening
        sockets, all of those things are too low level for programming languages. We need to build better abstractions on top, that get at what we're actually trying to do here. Okay, now I'm going to say that again. Files, our programming language shouldn't
        be able to write to the file system. There's a higher-level goal that we want the program to do, and the abstraction should encode that.
	</div>
	<div class="block">
		<div class="time">00:23:22</div>
		<div class="name">SK:</div>So, maybe you want some data to be saved somewhere. You could talk about that, but how it's saved, maybe you say, "I want this data saved locally," and then yes, your programming language will write it to the file system. Or you could
        say, "I want this data saved to the cloud somewhere," and then it'll do that as well, but you shouldn't have to talk about the file system, and you shouldn't have to, like, open a connection to a database in order to get those things persisted.
        Oh, so I'm just going to stop talking about this point.
	</div>
	<div class="block">
		<div class="time">00:23:51</div>
		<div class="name">SK:</div>I could talk about it for a while, but so point number five is we need to rid ourselves of the IO monad, so FRP's about doing that in user interfaces, but I've also started working on how we're going to do that for the backend, like what
        is a user? What is the denotation of a user? What about data? What about realtime multiplayer games? What about a cloud app? How would you do all these things without the IO monad, without explicitly making a request to a database?
	</div>
	<div class="block">
		<div class="time">00:24:24</div>
		<div class="name">SK:</div>In other words, we're blurring, very, very much so blurring, the line between frontend and backend from your code, kind of like Meteor, but even more so. You describe your user interface, and then maybe you lift an event. So, you have
        a button click. So here's an example. A classic FRP, first hello world app, is a button that counts its clicks, a counter button. So, that makes a lot of sense. Basically, you say, "Here's the button," and you say, "Inside the button, or off to
        the side of the button is the count of all click events that will ever happen on this button." Very declarative, beautiful. So now let's say I want a multiplayer button. Anyone who loads this app on their screen should be able to add to a global
        counter variable.
	</div>
	<div class="block">
		<div class="time">00:25:12</div>
		<div class="name">SK:</div>So basically, what you want is to be able to take this event, that's on my computer, the click events, and lift it to a cloud-based click event, that like everyone can get access to, and then sum over, then count the clicks in that thing.
        This is a hard thing to explain, and partially it's because I have a very hand-wavy understanding of it, but I'm excited about it, and I talk more about it on my website, in my log and other places. So anyways, that's point number five, rid ourselves
        of the IO monad.
	</div>
	<div class="block">
		<div class="time">00:25:47</div>
		<div class="name">SK:</div>Point six, we must have an editing experience that's lively and fluid. The mathematical abstractions we'll need to rid ourselves of the IO monad and build denotative languages scare people, partially because they're UI things, partially
        because the abstractions are complicated. So, this is a very difficult UI problem, to build this programming experience around denotative languages, but it's tractable. It may be one of the most complicated user interfaces ever created itself,
        but it's possible to build.
	</div>
	<div class="block">
		<div class="time">00:26:21</div>
		<div class="name">SK:</div>Okay, so the next section is vague dream programming language system. So, I'll just read some bullets. It's a Haskell-inspired, structured-ish editor in the style of Lamdu, early Unison prototypes, Luna, Isomorf, et cetera. This UI problem
        is large and unsolved, and it will likely be one of the most complicated UIs ever created. Eventually, bootstrapping it would be great, because the goal of this tool is to be able to build user interfaces, so you might as well build it in itself,
        and then of course, people will be able to make it better and more customized for what they want, which is the whole point of the project.
	</div>
	<div class="block">
		<div class="time">00:27:05</div>
		<div class="name">SK:</div>Okay, so web-based. It'd be great if it could run entirely in browsers, but it wouldn't be the end of the world if it had to communicate to some server in the backend, to do some processing or whatever. Maybe one day it'll compile to
        web assembly, I don't know. It recently occurred to me that this vision will require, I think, moving past the web, HTML, CSS, and JavaScript, and all the web-standard stuff, partially because it has such different goals from the web. It's trying
        to be so much more peer-to-peer, as opposed to like what the web is now, which is like Silicon Valley makes things, and everybody else uses them.
	</div>
	<div class="block">
		<div class="time">00:27:54</div>
		<div class="name">SK:</div>There are a lot of peer-to-peer internet projects happening now, like Dat and Beaker Browser, some Blockchain- y stuff, and it's related to that, but it's different, because the security model right now is very restricted, because the
        code is so complicated that we can't expect people to read it and understand it, so we need to protect them from themselves, from installing something that they don't know what it'll do, but in this world, where we want to give people the autonomy
        to build their own things, the security system needs to be a little bit more permissive, but also more typed somehow, because we're really concerned about denotative languages.
	</div>
	<div class="block">
		<div class="time">00:28:30</div>
		<div class="name">SK:</div>So anyways, that's one reason, and another reason is I was recently given a tour of Pharo, and The Glamorous Toolkit, by Tudor Girba, and he made a really good point that if you want a system that's truly moldable, it needs to be created
        in a single render tree. The single render tree concept is a point that I don't really understand why it's important, but it feels really important to me, that we need to blur the lines between apps. So-
	</div>
	<div class="block">
		<div class="time">00:29:00</div>
		<div class="name">SK:</div>... between apps. So, if you have ever seen the Alan Kay STEPS project or maybe early SmallTalk stuff, there aren't really clear distinction or boundary points between apps, like the whole system is cohesive more and there are definitely
        pros and cons to this. You have less polished single purpose apps, but you have more composability between little tools. In the past it's always been done in a way that, to me, felt very, very messy, like overlapping windows, just texts that can
        side effect anything anywhere, context everywhere. It felt like a mess. But I think it can be done well with strong types and a right focus on making it be really comprehensible somehow. So we're blurring the line between apps but we're having
        strict lines on types.
	</div>
	<div class="block">
		<div class="time">00:29:54</div>
		<div class="name">SK:</div>All right, another point is definitions or expressions will be hash based in the style of UNISON and maybe IPFS. I want to really take immutability seriously and it's crazy how you edit a Haskell program by mutating the text, it's crazy.
        If we're gonna take immutability seriously, we really got to take it seriously. But on top of this immutable expression-ey world, I guess we'd probably need a mutable naming system. So I make a website and then I want to make a change to it and
        the hash will change because it has to because the definition changes, but I want some sort of consistency of identity. So it's still my website so I want whoever wants the newest version of I have my website to get the new version, not the old
        version. So maybe a naming system in the style of DNS or something more modern or peer to peer. Where specific people get rights to assign names to hashes and reassign them whenever. I don't quite know how that'll work out. Open research problem.
	</div>
	<div class="block">
		<div class="time">00:31:00</div>
		<div class="name">SK:</div>Next bullet. So live programming in the sense that terms are evaluated immediately, even if they're incomplete, in the sense of Hazel. So here we're entirely blurring the line between running and stopped code. Like your code is just running
        all the time in pieces, there's no such thing as running code any more than there's running or pausing a Google Doc. You can look at a Google Doc, you can close a Google Doc, you can delete a Google Doc, but you can't run it or stop it from running.
        And so I think I like that metaphor for this; you have code and it just runs or, if something refers to it, it's on the screen or in use somewhere, it'll run. So you have to kind of disconnect it or something if you want to stop.I'm very vague
        on this sense but it feels important. Of course we don't want people to not be able to stop code that needs to be stopped. You know, we'll allow that. But I think the metaphor of, " You wrote some code, you have to press a button and then it runs
        and then it stops when it's done," that should go away.
	</div>
	<div class="block">
		<div class="time">00:32:06</div>
		<div class="name">SK:</div>The way I think about this, it's kind of like your coding in pieces. I don't know if you've used a Photoshop app or Sketch or something where you have this big open, infinite canvas and you have different pieces of your designs in different
        places on the screen, you can kind of scroll around and drag things around? That's kind of what I'm imagining for code and I'm getting this from Jason Brennan. He has an app platform he calls Beach where that's kind of the metaphor, of an open,
        infinite canvas.
	</div>
	<div class="block">
		<div class="time">00:32:36</div>
		<div class="name">SK:</div>All right, the last bullet. Actually I have two more. Working on something new doesn't break anything existing. Changing a definition only produces a new definition, but you are given the option to update old hashes to the new definition
        if you wish. So it's like kind of a factoring tool. So if you have a whole connected tree of definitions and you change one in the middle, it'll say there are a lot of things that depended on this old hash, do you want to create copies of all
        of the other definitions and point them at this new hash and all the things that you'd want. And I think UNISON is dealing with a lot of these research problems and maybe they'll be able to help here. It's complicated but I think it's the right
        framing for version control and collaboration.
	</div>
	<div class="block">
		<div class="time">00:33:23</div>
		<div class="name">SK:</div>And then I think I said this before but, to reiterate, we're entirely blurring the line between front and back end coding. We were collapsing the distinction to one of my computer and data from elsewhere, or Cloud data. Computation can
        happen anywhere you want and maybe you have to put your credit card or something in the code somewhere in order to make the computation happen on someone else's computer or in the Cloud, something like that.
	</div>
	<div class="block">
		<div class="time">00:33:54</div>
		<div class="name">SK:</div>So now there are four big problems in order to make this vision a reality that I've talked around in the last text but I'm just gonna make them explicit now. So number one is ridding ourselves of the IO monad. And now sub 1a is user interfaces,
        1b is back end users' databases. Basically we wanna rid the IO monad from everywhere. Number two is collaboration version control branching, and that's what I've been talking about recently about hashes and names and that kind of thing. The hashes
        and the not being able to change thing, that's also related to number three, the programming experience. And I mentioned before, given how difficult it is to use denotational languages without the IO monad, the types and abstractions are so complicated,
        we're going to need to spend a lot of time thinking about a really good programming experience in order to make these things usable by millions of people. programmers and people who want to learn to program.
	</div>
	<div class="block">
		<div class="time">00:35:05</div>
		<div class="name">SK:</div>And then the fourth problem is adoption. So we have this beautiful system and how do we get people to use it? And particularly the issue is, if we make it it's own world, kind of like Squeak or Pharo or the Lively Web, Lively Kernel systems,
        those systems tend to be isolated systems that only a handful of devoted people use and they don't spread out to the rest of the world. So how do we break out? So here's one idea I have: we start with a killer app. And so people often talk about
        that, in order for a platform to succeed, it needs a killer app. So Microsoft had, I think it was Microsoft, had a spreadsheet app, Lotus Notes. I don't know if it was Microsoft, maybe it was IBM's. Someone had a spreadsheet, someone ... there
        was a new operating system that was created and then Lotus Notes is why people bought it. And so, for the Internet people, say, the killer app was email. And so I think, it may be a little bit too cute to say this, but I think we could steal the
        Internet's killer app of email and here's why I think so.
	</div>
	<div class="block">
		<div class="time">00:36:22</div>
		<div class="name">SK:</div>Everyone's email workflow is specific and it's a huge part of how we all run our lives. Being able to customize things to exactly how we'd like them would be a super power. For myself, I'd like to be able to combine my email app with
        features of task management applications such as reordering items, nesting items within other items, assigning them to people, emailing them to people. Basically I want my inbox to be really like a kit of, you know, I get incoming emails, I can
        drag them to wherever I want, elsewhere in my computer, I can reply to emails in a nested thing somewhere else. I want something that looks a lot less like an email app and basically I want my email app embedded in all the other tools I use to
        manage my life.
	</div>
	<div class="block">
		<div class="time">00:37:15</div>
		<div class="name">SK:</div>And I think that this is why we've all struggled so much to find systems that we like. People are constantly looking for new note taking apps, new to do list apps, new email apps, because they're all isolated and what we really want,
        the solution that we all want, is something where we can build our own workflow that merges all the tools that run our life to suit us best.
	</div>
	<div class="block">
		<div class="time">00:37:39</div>
		<div class="name">SK:</div>So part of the inspiration for this killer app idea is that Google inbox, my own preferred email client, is being shut down in a few months by Google. So people always talk about how Google does this, but this is the first time it's really
        hit me. It really, really hurts and then now I finally have learned to not trust Google or any company that makes apps because the economics of building apps are crazy. It's so cost intensive to build a quality app that you need to get millions
        of people to use it to justify the cost of initial and maintaining the development of it. It's really, really a sad state of the world we live in and we're all gonna have lowest common denominator software because of it, because it needs to work
        for so many other people. The only way to maintain quality personalized experiences is with a crowd sourced development platform and that's what we're trying to build here. That's the whole mission. And initially I imagine we leveraged Gmail's
        API to do this and try and take shortcuts.
	</div>
	<div class="block">
		<div class="time">00:38:45</div>
		<div class="name">SK:</div>Okay. Now I have a, "How is this different from," section. Kind of messy but basically I compare my vision, my dream system to UNISON, , Luna, Isomorph and Dark, because those are also Haskell inspired structure editor things. The main
        difference between what I want to build and all of those systems is that I'm focused on the construction of user interfaces and none of those systems are focused on the construction of user interfaces. I'm also really concerned about this moldability
        of your own computing environment, in the Pharo sense, and none of those, I don't think, are really focused on that. One open question is, given that we don't want to expose IO to the user at all, how do we enable developers of this tool, this
        dream tool to write ... how do we enable them to write abstractions over IO because that's gonna be necessary. So a one way to handle it as we could use the IO monad, like Haskell maybe, and lower levels. We could have a few different levels.
        I don't really know, that's an open question.
	</div>
	<div class="block">
		<div class="time">00:39:56</div>
		<div class="name">SK:</div>Okay, so. So that's my about page. Thanks for bearing with me, it only took 40 minutes to read it all when I'm sure it would have taken you a lot less time to read it yourself with your eyes, but this way you get a lot more context, so
        hopefully you enjoyed it. Okay. So now let's go a little bit more chronologically. So in the past few months, they've been good, I'll start with that. I ... So let's pick up where I left off. So, the last reflection I was just putting the finishing
        touches on my paper about FRP that I was gonna submit to Rebels, explicitly comprehensible FRP.
	</div>
	<div class="block">
		<div class="time">00:40:48</div>
		<div class="name">SK:</div>So, good news, paper was accepted. Great news actually, it was really fun to prepare for the talk and give the talk and get some feedback. It was all wonderful. So the talk was accepted, they gave me some really good feedback from the
        reviewers that I incorporated and then Jonathan Edwards came up with the idea for me to record me doing a talk with the slides and then sending it around to a few friends. And then we all got together and Jonathan Edwards led a writer's workshop
        format feedback section where I stayed quiet and just took notes and everyone else talked about the good and bad things about it and how to make it better. It was really, really well done. So thanks, Jonathan Edwards, for organizing that. And
        also, you know, for making this paper happen. Without Jonathan's mentorship I wouldn't have known to write the paper, I wouldn't have known where to submit the paper. None of it would've happened. So thank you Jonathan. And also, thanks to my
        friends who joined for that feedback session. Jeffrey Lit, Ivan Reese, Joshua Horowitz, and Johnathan Edwards for organizing it. And thanks Glen for his notes separately.
	</div>
	<div class="block">
		<div class="time">00:42:00</div>
		<div class="name">SK:</div>All right. So I think in the last research recap I said that I might read the final version of my explicitly comprehensible FRP paper on this podcast. I don't think I want to do that, the talk version is on the Internet, the paper version's
        on the Internet, the slides are on the Internet. Futureofcoding.org/papers/something. If you just type futureofcoding.org/papers you'll get there. Or if you just go to the futureofcoding.org, it's right at the top. I'll just do a quick summary.
        Basically, I complained about the Elm Architecture, which has since gone on ... it was started in Elm but it has since gone on to inspire REAX, Redux, Vues, Vues.js and .
	</div>
	<div class="block">
		<div class="time">00:42:50</div>
		<div class="name">SK:</div>So the thesis or the point of my talk and my paper is that FRP has become really popular in web development these days, and mobile development. Basically, UI development is dominated by FRP. And the industry seems to have agreed that
        the Elm Architecture is the solution.
	</div>
	<div class="block">
		<div class="time">00:43:11</div>
		<div class="name">SK:</div>Let me describe the Elm Architecture briefly. It's characterized by a single state tree where all of the state free application is stored in one object. And then the Vue, the way your app looks, the html or whatever, is a pure function
        from that tree, to some html value, that state tree to some dom tree. And then your Vue emits events which are then pattern matched on by this reducer function. So the reducer function takes the previous version of the state, the current value
        of a state, and an event, from the Vue and updates the Vue. It's immutable but it's updating the Vue, it's producing a new value of the state one tick forward in time. So, if you have a counter, the initial value of the state would be counter
        zero, that would be passed to the Vue which would make a button with zero in the button. The button would have a unclick event, it would emit at an increment event and then the reducer would say, "Oh, when I get an increment event take the old
        value of the state, add one to it, put it back into the counter piece of state." If you don't already understand the Elm Architecture that's not really going to help you but hopefully that was a good summary for those of you who already understand
        it.
	</div>
	<div class="block">
		<div class="time">00:44:42</div>
		<div class="name">SK:</div>So the industry of user interface people, especially in Silicon Valley, have kind of circled around this Elm Architecture single state tree plus reducer way of doing things. And the point of my explicitly comprehensible FRP paper is to
        say that that's not a great solution. That solution is very, very similar to mutable imperative programming. It's not really functional programming. And the point I make is you have global state, it's basically mutable and basically anywhere in
        the code you can emit a thing that will change a piece of state. So it's really hard to understand how pieces of state behave over time. Worst of all, it doesn't force you to be explicit about which pieces of state depend on other pieces of state
        and which pieces of state, by their absence, are independent of other pieces of state. So this is a really important thing.
	</div>
	<div class="block">
		<div class="time">00:45:46</div>
		<div class="name">SK:</div>So, going back to my overall mission, we want to make the comprehensibility of large software quick. We want really fast comprehensibility. Particularly, you're using a big application to do something with your life. You want to change
        a small part of it. You don't understand the whole thing, you don't want to understand the whole thing, you just want to change a small part. So in order for that to be possible, you need to be able to really quickly determine which parts of this
        large codebase are relevant and which parts are irrelevant to the change you're trying to make right now. And so, given that the code is thousands or tens of thousands or millions of lines long, you need the computer to help you automatically
        make that determination. And the only way the computer could help you is if we've been explicit in the code about which pieces of state are dependent and which pieces of state are independent of each other. So that's why this is so key. And that's
        why I'm very bearish on the Elm Architecture. No, bullish, I don't know, I'm not excited about the Elm Architecture.
	</div>
	<div class="block">
		<div class="time">00:46:48</div>
		<div class="name">SK:</div>So, what's the alternative, you ask. Thanks for asking. So I think the alternative is to go back to the original conception of FRP that Conal Elliot came up with, with Paul Hudak, in the '90s. And in order for us to do this we need higher
        order and cyclic streams. So the justification of why we need higher order and cyclical streams in order to escape the hell of the Elm Architecture, that's a complicated point that I haven't even fully convinced myself of but just assume it to
        be the case. So we need high order and cyclical streams. And those really aren't around in very many places.
	</div>
	<div class="block">
		<div class="time">00:47:31</div>
		<div class="name">SK:</div>After a lot of searching I found them in Haskell, in this library called Reflex which you can use for web development via the ghcjs compiler. But it was a real pain, I Haskell but it's just getting it to install and run and compile, it's
        just kind of a nightmare. Particularly just the feedback loop. I write some code in Emacs because I have to be in a show or whatever ... because I use a Chromebook so I can't compile it unless I'm ssh somewhere. So I write my thing in Emacs, I
        save, I use Emacs to go to another buffer thing and run my code and wait three or four seconds and then tab over to a new window, refresh the window; it's a nightmare. 10 seconds between feedback loop cycles, it's a nightmare, even just for things
        like syntax errors.
	</div>
	<div class="block">
		<div class="time">00:48:24</div>
		<div class="name">SK:</div>So, as an aside, after this project, actually just last week, I went around trying to set up a better Haskell development environment for myself. I went around offering Haskell developers money to help me set it up in a way that would
        be more fluid and live and nobody could do this for me. I asked on Twitter, basically it's a chimera, a fluid Haskell experience. People talk about it, but I'm dubious it exists. Or maybe it exists but it takes so long to install all the things
        and the dependencies and fix all the bugs that, once you've done it once on your computer, you don't want to do it on someone else's computer. It's not a repeatable process. Maybe I'm wrong. If I'm wrong and you're listening to this, please let
        me know. I'd love to get that set up. But luckily I found a good alternative which I'll talk about in a second.
	</div>
	<div class="block">
		<div class="time">00:49:15</div>
		<div class="name">SK:</div>So, anyways, back to explicitly comprehensible FRP. If we use higher order and cyclical streams we can regain the comprehensibility of radial functional programming. In other words, when you read some code you can be sure that the definitions
        are reading are definitional. Nowhere else in the code can side effect the definition you're reading to change it. If you want to understand a piece of state, you just read its definition and the definitions of the terms it refers to recursively,
        that's it. Explicit data dependencies and explicit data independencies, which is what's needed for, for global code comprehensibility in a quick way. Or piecemeal comprehensibility in a quick way.
	</div>
	<div class="block">
		<div class="time">00:49:58</div>
		<div class="name">SK:</div>Okay, so that's explicitly comprehensible FRP, in a way too short amount of time. So go on the Internet if you want to know more. So, as I was saying, Haskell was just a pain but luckily in the last few days I found this library called
        Turbine. So actually I'd seen it a couple months ago but I passed it over for some dumb reason. But luckily a few days ago I popped on Twitter to waste time and I was thwarted, my time was used very productively, because right at the top of my
        Twitter feed was Conal Elliot praising an essay written by the Framework creator, Simon Friis Vindum, of Turbine. And so I read it and revisited it and I was like, "Holy crap, this is exactly what I'm looking for." And so I played with it for
        a few hours and it was great. Really it's similar to Reflex, there's a few things I like about it less but it wins by a mile, simply for the reason that I was able to install it in two seconds. I still need help setting up typescript but I was
        able to install it without typescript for two seconds, or very quickly, and then on every key stroke it'll reload the page, like instantly. It's so quick to compile and run it. So, for that reason alone, it warns me about syntax errors, it warns
        me about silly errors. It's just so much, so much better.
	</div>
	<div class="block">
		<div class="time">00:51:30</div>
		<div class="name">SK:</div>So that was a really big win and I have since emailed Simon about maybe collaborating. They need documentation, I need help setting up typescript. I need to be able to figure out how to inspect my streams better. There are a lot of like
        little low hanging fruit things that could really improve the library a lot. So I'd love to help with that somehow or collaborate on that somehow, so we'll see if we can get that set up but he seems to be busy with schoolwork and stuff because
        he's in school, I think. So in the meanwhile my next steps in this thread of removing the IO monad from UI is ... my next steps might be with Turbine to build some sample apps and just get more and more used to the library.
	</div>
	<div class="block">
		<div class="time">00:52:18</div>
		<div class="name">SK:</div>There's this wonderful project called 7GUIs, which is kind of to do on VC but even more legit instead of just TodoMVC there are seven tasks. I'd really love TodoMVC because it embodies a lot of what's hard about UI programming. But 7GUIs
        is also good. So maybe I'll build some 7GUIs things or play with the TodoMVC or think about what a devtools extension for it would look like. Maybe I'll write some documentation or something. He sent me a tutorial that he wrote so maybe I'll read
        that, I don't know, things like that. Next steps.
	</div>
	<div class="block">
		<div class="time">00:53:00</div>
		<div class="name">SK:</div>Okay. So once Turbine is in a decent spot and I feel like I can use it to actually build things the next step is to build something. Build what, you ask? So you remember that programming experience thing I was mentioning before. So once
        we removed the IO monad from user interface construction what we'll have left is a really beautiful way to build user interfaces, but it's really hard to use. So, even after I make all the improvements I want to make to Turbine, programmers may
        be able to use it but not most people. And it's like programming is needlessly bad, especially because we have all these wonderful abstractions, we should be able to build some sort of wonderful programming experience on top of it. So I'm calling
        this prototype P4. I've built three prototypes in the past, approximately three prototypes in the past. For quick summary, the first prototype was blocks for jQuery, the second prototype was blocks for React.js and then the third prototype was
        a structured editor for Javascript, which I called Rose. The first two I called Cycle v1 and Cycle v2 and then this is P4.
	</div>
	<div class="block">
		<div class="time">00:54:22</div>
		<div class="name">SK:</div>All right, so I spent a little bit of time working on P4 in the last three months. This may be a little bit surprising to those of you who listened to the last research reflection and thought ... where I said that I was going to be working
        on this sort of thing, like visual metaphors for streams full time. But that didn't quite happen the way I expected for a few different reasons. But one of the main reasons is that I don't really like drawing things or at least I need to come
        up with a better way to encourage myself to do it.
	</div>
	<div class="block">
		<div class="time">00:54:53</div>
		<div class="name">SK:</div>But really the main reason was that it's quite difficult to build a editor that is direct manipulation-ey, you know, it looks like buttons and you can drag them and whatnot and change their color. But also abstract. And so what I mean
        by abstract, or expressive instead of abstract, is that, if you want a system to be fully programmatic, anywhere you put a widget, like a slider number or a picker, anything you put like an interface, a UI thing, I need to be able to put any expression
        there, fully nested as deeply as possible. So basically what you realize is , basically I just want to expressions everywhere and occasionally some of the expressions could be represented as UI but you need to be able to get rid of the UI and
        just put another expression there. So that's kind of like Bret Victor's scrubbing idea, so you have a regular programming interface but then the numbers can be scrubbed.
	</div>
	<div class="block">
		<div class="time">00:55:52</div>
		<div class="name">SK:</div>So that that's kind of where I'm at now. We have a regular programmatic interface but then, if you have a color, obviously it's not just a color, it's a color picker. Like if you have a color literal. So all the literals in your system
        are interfaces that can be deleted but everywhere else it's expressions. That's my new thesis. I don't know if that'll be the best thing ever but that's a good place to start. And then streams; in the past I thought maybe streams could be something
        that we interact with, maybe, but right now I'm thinking, again, they could be like annotation to the code, to illustrate how the expressions are working but you have text based expressions, that's the main way you look at the code other than
        looking at the output. So then, if that's what it's about, then I guess I'm in projectional editor land. And so that's why earlier in this episode I talked about Luna, LIM, Do, Isomorph, Dark, UNISON, etc.
	</div>
	<div class="block">
		<div class="time">00:56:50</div>
		<div class="name">SK:</div>Okay. Yeah, and I guess I already spOke about a lot of the things for P4 in the dream section of my about page that I already read here, so I can kind of skip a lot of that. One extra note I see here is that the fast feedback loop is
        really, really important. Pretty straight forward. The term 'live' comes to mind, live programming. It's a term that we use a lot, Sean McDermon used a lot. He actually quotes the original guy who came up with the term but I forget his name. But
        what live is about, at least to my current memory, is it's about when you make an incremental action, you get an incremental result. And I think that that's really important for fluidity, the feeling of fluidity and the feeling of flow. You make
        a thing, you see something. You press a key on a keyboard, you make a click, you see something immediately, as soon as you do anything. Even if it's just a loading icon or something, just to tell you that the action you took had a semantic meaning.
        We heard you, it helps you feel heard-
	</div>
	<div class="block">
		<div class="time">00:58:00</div>
		<div class="name">SK:</div>… meaning. We heard you. Helps you feel heard. Another note I have here is that types should feel like guides, not like they're yelling at you like referees. That's a really important distinction, because all statically type languages
        that I've worked with, they allow you to write code, and you hit a button, and then they yell at you. It's like the compile button is like the yell at me now button, which is really an annoying button.
	</div>
	<div class="block">
		<div class="time">00:58:25</div>
		<div class="name">SK:</div>I think what you want instead is you want an environment where it lets you do dumb things from a type perspective, but it warns you. It kind of like underlines your mistakes in red, like when you're writing in a Google Doc or whatever,
        and you spell something wrong. It'll just underline it in red so you can come back later and fix it. The main selling point of types is that they're automated reminders for you to handle all the cases you forgot to handle. That's the real selling
        point of types. If that's the selling point, they're just reminders. They should be off to the side. They shouldn't prevent you from doing what you're trying to do. I think that's really important.
	</div>
	<div class="block">
		<div class="time">00:59:10</div>
		<div class="name">SK:</div>Let's see. Here's another idea. In this P4 system that I'm trying to build, and I'd probably build it with Turbine or something like Turbine, how do I start? Like what's the first thing that I want P4 to ... What's the first thing I want
        to be able to build within P4? What's a motivating problem? I have all these UI problems that are ... The true motivating problems for P4 are seven GUIs and TodoMVC. Those are the true motivating problems, but it might make sense to not start
        there, because UIs are complicated: higher order and cyclical streams. They're really tough, so it might make sense to start with pure FP problems, like drop their reactive bit again, and just work on like, data transformation problems.
	</div>
	<div class="block">
		<div class="time">01:00:07</div>
		<div class="name">SK:</div>Joshua Horowitz recently, well, he presented it live, and then recently published on the internet, a project called Pain, which is very much in the spirit. It's very Haskelly. It's pure data transformations. So maybe I could take his
        problem statement as my own, build like a user-interfacey thing for pure data transformations that's also very live, and shows you the intermediate data, et cetera. Maybe I can even draw inspiration from Pain.
	</div>
	<div class="block">
		<div class="time">01:00:34</div>
		<div class="name">SK:</div>Then once I've done that, I can maybe build up to a higher order and cyclical streams. The difficulty in that strategy is that I'll build something neat, then it won't scale up to higher order and cyclical streams, so I have to really
        have the higher order stuff in mind while I'm doing the lower level things. Yeah, it's hard.
	</div>
	<div class="block">
		<div class="time">01:00:58</div>
		<div class="name">SK:</div>I think a key realization I'm coming to is that abstractions are really complicated, and they're varied. That's why visualization is so hard in programming. But if I stick to text as my UI, then I can represent any abstraction in text,
        so that's a good cheat. Basically, it's the idea of all those other pros that I keep talking about. Like lambda, for example. You have the text there, and then you can have visualizations, or live data annotating the abstraction, the core abstraction.
        That's my current approach somehow.
	</div>
	<div class="block">
		<div class="time">01:01:41</div>
		<div class="name">SK:</div>The next section in my list is the multi-node FRP, removing the I/O monad from the backend, but I kind of already talked about it in this podcast, so I'm gonna go ahead and leave it at what I said earlier, basically lifting events from
        one computer to multiple computers. I'll tease you with one other bit of hand-wavy nonsense, and if you want to know more, I actually have an issue on GitHub issues for this episode. It's on my website somewhere. You can find it, or you can email
        me, but I'll just tantalize you with one other tidbit of multi-node FRP that I've come up with.
	</div>
	<div class="block">
		<div class="time">01:02:24</div>
		<div class="name">SK:</div>Denotationally, I have a question for you. What is a user? What is a user? The first thought I had was: Users are, well, this thing you have to create. So like on every website I go to, I go and create an account. What's the denotation
        of creating an account? Then it hit me. Stop thinking like a mutable ninny. Stop thinking like you're programming in Java. Creating in a thing is very, very mutable. Is a mutable idea, so I threw that away. What is a user?
	</div>
	<div class="block">
		<div class="time">01:02:57</div>
		<div class="name">SK:</div>So I came to the conclusion that a user is a way to identify oneself. It's like an ID, and it's a way to authenticate oneself. It's a way to verify that the thing I say is truly tied to the ID that I purport to have. That's what a user
        is, and if that sounds familiar, that's because it is. That's a public and private key cryptographic pair. That's like the ideal denotation of a user. It's a private key, public key. It's a two-pool. Was your mind blown?
	</div>
	<div class="block">
		<div class="time">01:03:31</div>
		<div class="name">SK:</div>That's what a user is. If I have a public key and a private key, and I want to set my username, so in a set, it sounds imutable, but basically what I can do is say, I can sign a statement saying, "My username is X", with my private and
        public key, and then everyone knows that's what my username is. In the future if I say, "My username is Y", then they know my username was X and now it's Y. That's what I mean by set. It's a stream notion of set. I'm not setting anything, I'm
        just updating. The stream has multiple values based on the value of time.
	</div>
	<div class="block">
		<div class="time">01:04:13</div>
		<div class="name">SK:</div>Anyways, I'm really excited about this abstract notion of a user as just a private and public key. If you're creative, you'll realize holy crap, if that's what a user is, then we can say goodbye to all the crazy, annoying notions of creating
        different accounts for different services. We can literally delete that.
	</div>
	<div class="block">
		<div class="time">01:04:33</div>
		<div class="name">SK:</div>You go in your browser. You paste your private key, you paste your public key, and then you can go around the internet just trusting that everything you do is identified as you because your browser just has the information to sign all
        of your actions as you. You never have to login again. You never have to create an account again. You never have to change your password again.
	</div>
	<div class="block">
		<div class="time">01:04:52</div>
		<div class="name">SK:</div>Obviously there's some issues with security and whatnot, but I think it's a really cool idea of just getting back to the root of what a user is. Cool. Okay, that is multi node FRP, removing I/O from the backend.
	</div>
	<div class="block">
		<div class="time">01:05:14</div>
		<div class="name">SK:</div>Another point is version control. I mentioned that was one of my big problems in order to accomplish this mission. I haven't spent very much time at all thinking about this, but I did create a prototype. Actually, that should probably
        be P4, but anyways, that one has a name. It's a WoofJS Workflow. You could find it on my website, futureofcoding.org. It's a really neat, I think, exploration of what version control would look like. It's very fluid. I think I've explained it
        on this podcast before. I think yeah, about a year ago.
	</div>
	<div class="block">
		<div class="time">01:05:51</div>
		<div class="name">SK:</div>Instead of using Git with normal branches, imagine a infinitely nestable bulleted list. You're just editing this list as you would a text file, but it's actually branches of code. Part of what I think that enables is collaboration multi
        levels deep, because right now in Git, pull requests are really just only off of masters. We don't have multilevel deep pull requests. I think part of the reason is the tools are not fluid at all. You can't merge things. It just, anyways, that's
        its own point. If you're interested in WoofJS Workflow, rewind the podcast to that episode, or go check it out on the internet.
	</div>
	<div class="block">
		<div class="time">01:06:33</div>
		<div class="name">SK:</div>That's not to say that WoofJS Workflow is the answer to version control for this system. Not even close. WoofJS Workflow is just one experiment. I'd love to see more version control ideas in the future. I've only seen a very small handful,
        there's this website - like Elements of Change - where someone was focused specifically on the version control problem. I'd love to see more people focus on this problem, 'cause eventually I'm gonna have to focus on it if nobody else does, and
        that would be annoying.
	</div>
	<div class="block">
		<div class="time">01:07:06</div>
		<div class="name">SK:</div>But it's a really, really interesting hard problem, version control, and maybe there's been interesting work on it. Clearly Git isn't the answer for all time, so if anyone knows of good research on the future of version control send that
        my way, I am all ears.
	</div>
	<div class="block">
		<div class="time">01:07:29</div>
		<div class="name">SK:</div>It's a this point in the podcast that I'm realizing that you might be confused as to what it is that I'm building, the goal. So I've mentioned that I want this system that's kind of like Wikipedia for software, where anyone can change
        things, blah blah blah. In order to do that we need to remove the I/O monad, blah blah blah blah blah. Okay.
	</div>
	<div class="block">
		<div class="time">01:07:52</div>
		<div class="name">SK:</div>So, if you got all that, great job, you've been listening well. But you may be confused 'cause I have this thing P4, and you're like "well, is P4 the thing you want to be that beautiful system?"
	</div>
	<div class="block">
		<div class="time">01:08:03</div>
		<div class="name">SK:</div>The answer is "probably not", P4 is just a prototype to point us in the right direction of removing the I/O monad from user interface construction. Just as WoofJS Workflow was a prototype to point us in the right direction for version
        control fluidity. They're just prototypes that continue to point me and get me closer and closer to this overall dream platform.
	</div>
	<div class="block">
		<div class="time">01:08:25</div>
		<div class="name">SK:</div>Maybe at one point, this given prototype will morph into the dream platform itself. I'll get close enough it'll happen that way, but I really don't know. I don't think I'm close enough that P4 will be the one that mutates and morphs its
        way over the finish line.
	</div>
	<div class="block">
		<div class="time">01:08:45</div>
		<div class="name">SK:</div>Okay, so now I'm gonna take a pivot and talk about sustainability. So, I think maybe it 
	</div>
</div>

<script>
// linkify each block of text with a unique ID
[].slice.call(document.querySelectorAll('.block')).map(b => b.firstElementChild).forEach((el, i) => {
  var a = document.createElement('a');
  a.href = "#" + i;
  a.name = "" + i;
  el.parentNode.insertBefore(a, el);
  a.appendChild(el);
})
</script>

<script repoPath="stevekrouse/futureofcoding.org" type="text/javascript" src="/unbreakable-links/index.js"></script>
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-103157758-1', 'auto');
ga('send', 'pageview');
</script>
